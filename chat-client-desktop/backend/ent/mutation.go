// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"

	"github.com/yihleego/chat/backend/ent/chatmate"
	"github.com/yihleego/chat/backend/ent/conf"
	"github.com/yihleego/chat/backend/ent/contact"
	"github.com/yihleego/chat/backend/ent/group"
	"github.com/yihleego/chat/backend/ent/groupmessage"
	"github.com/yihleego/chat/backend/ent/message"
	"github.com/yihleego/chat/backend/ent/predicate"
	"github.com/yihleego/chat/backend/ent/session"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeChatmate     = "Chatmate"
	TypeConf         = "Conf"
	TypeContact      = "Contact"
	TypeGroup        = "Group"
	TypeGroupMessage = "GroupMessage"
	TypeMessage      = "Message"
	TypeSession      = "Session"
)

// ChatmateMutation represents an operation that mutates the Chatmate nodes in the graph.
type ChatmateMutation struct {
	config
	op                 Op
	typ                string
	id                 *int64
	biz_id             *int64
	addbiz_id          *int64
	_type              *int32
	add_type           *int32
	name               *string
	avatar             *string
	last_message_id    *int64
	addlast_message_id *int64
	last_chat_time     *int64
	addlast_chat_time  *int64
	clearedFields      map[string]struct{}
	done               bool
	oldValue           func(context.Context) (*Chatmate, error)
	predicates         []predicate.Chatmate
}

var _ ent.Mutation = (*ChatmateMutation)(nil)

// chatmateOption allows management of the mutation configuration using functional options.
type chatmateOption func(*ChatmateMutation)

// newChatmateMutation creates new mutation for the Chatmate entity.
func newChatmateMutation(c config, op Op, opts ...chatmateOption) *ChatmateMutation {
	m := &ChatmateMutation{
		config:        c,
		op:            op,
		typ:           TypeChatmate,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withChatmateID sets the ID field of the mutation.
func withChatmateID(id int64) chatmateOption {
	return func(m *ChatmateMutation) {
		var (
			err   error
			once  sync.Once
			value *Chatmate
		)
		m.oldValue = func(ctx context.Context) (*Chatmate, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Chatmate.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withChatmate sets the old Chatmate of the mutation.
func withChatmate(node *Chatmate) chatmateOption {
	return func(m *ChatmateMutation) {
		m.oldValue = func(context.Context) (*Chatmate, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ChatmateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ChatmateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Chatmate entities.
func (m *ChatmateMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ChatmateMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ChatmateMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Chatmate.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBizID sets the "biz_id" field.
func (m *ChatmateMutation) SetBizID(i int64) {
	m.biz_id = &i
	m.addbiz_id = nil
}

// BizID returns the value of the "biz_id" field in the mutation.
func (m *ChatmateMutation) BizID() (r int64, exists bool) {
	v := m.biz_id
	if v == nil {
		return
	}
	return *v, true
}

// OldBizID returns the old "biz_id" field's value of the Chatmate entity.
// If the Chatmate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChatmateMutation) OldBizID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBizID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBizID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBizID: %w", err)
	}
	return oldValue.BizID, nil
}

// AddBizID adds i to the "biz_id" field.
func (m *ChatmateMutation) AddBizID(i int64) {
	if m.addbiz_id != nil {
		*m.addbiz_id += i
	} else {
		m.addbiz_id = &i
	}
}

// AddedBizID returns the value that was added to the "biz_id" field in this mutation.
func (m *ChatmateMutation) AddedBizID() (r int64, exists bool) {
	v := m.addbiz_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetBizID resets all changes to the "biz_id" field.
func (m *ChatmateMutation) ResetBizID() {
	m.biz_id = nil
	m.addbiz_id = nil
}

// SetType sets the "type" field.
func (m *ChatmateMutation) SetType(i int32) {
	m._type = &i
	m.add_type = nil
}

// GetType returns the value of the "type" field in the mutation.
func (m *ChatmateMutation) GetType() (r int32, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Chatmate entity.
// If the Chatmate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChatmateMutation) OldType(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds i to the "type" field.
func (m *ChatmateMutation) AddType(i int32) {
	if m.add_type != nil {
		*m.add_type += i
	} else {
		m.add_type = &i
	}
}

// AddedType returns the value that was added to the "type" field in this mutation.
func (m *ChatmateMutation) AddedType() (r int32, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetType resets all changes to the "type" field.
func (m *ChatmateMutation) ResetType() {
	m._type = nil
	m.add_type = nil
}

// SetName sets the "name" field.
func (m *ChatmateMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ChatmateMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Chatmate entity.
// If the Chatmate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChatmateMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ChatmateMutation) ResetName() {
	m.name = nil
}

// SetAvatar sets the "avatar" field.
func (m *ChatmateMutation) SetAvatar(s string) {
	m.avatar = &s
}

// Avatar returns the value of the "avatar" field in the mutation.
func (m *ChatmateMutation) Avatar() (r string, exists bool) {
	v := m.avatar
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatar returns the old "avatar" field's value of the Chatmate entity.
// If the Chatmate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChatmateMutation) OldAvatar(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatar: %w", err)
	}
	return oldValue.Avatar, nil
}

// ResetAvatar resets all changes to the "avatar" field.
func (m *ChatmateMutation) ResetAvatar() {
	m.avatar = nil
}

// SetLastMessageID sets the "last_message_id" field.
func (m *ChatmateMutation) SetLastMessageID(i int64) {
	m.last_message_id = &i
	m.addlast_message_id = nil
}

// LastMessageID returns the value of the "last_message_id" field in the mutation.
func (m *ChatmateMutation) LastMessageID() (r int64, exists bool) {
	v := m.last_message_id
	if v == nil {
		return
	}
	return *v, true
}

// OldLastMessageID returns the old "last_message_id" field's value of the Chatmate entity.
// If the Chatmate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChatmateMutation) OldLastMessageID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastMessageID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastMessageID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastMessageID: %w", err)
	}
	return oldValue.LastMessageID, nil
}

// AddLastMessageID adds i to the "last_message_id" field.
func (m *ChatmateMutation) AddLastMessageID(i int64) {
	if m.addlast_message_id != nil {
		*m.addlast_message_id += i
	} else {
		m.addlast_message_id = &i
	}
}

// AddedLastMessageID returns the value that was added to the "last_message_id" field in this mutation.
func (m *ChatmateMutation) AddedLastMessageID() (r int64, exists bool) {
	v := m.addlast_message_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetLastMessageID resets all changes to the "last_message_id" field.
func (m *ChatmateMutation) ResetLastMessageID() {
	m.last_message_id = nil
	m.addlast_message_id = nil
}

// SetLastChatTime sets the "last_chat_time" field.
func (m *ChatmateMutation) SetLastChatTime(i int64) {
	m.last_chat_time = &i
	m.addlast_chat_time = nil
}

// LastChatTime returns the value of the "last_chat_time" field in the mutation.
func (m *ChatmateMutation) LastChatTime() (r int64, exists bool) {
	v := m.last_chat_time
	if v == nil {
		return
	}
	return *v, true
}

// OldLastChatTime returns the old "last_chat_time" field's value of the Chatmate entity.
// If the Chatmate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChatmateMutation) OldLastChatTime(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastChatTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastChatTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastChatTime: %w", err)
	}
	return oldValue.LastChatTime, nil
}

// AddLastChatTime adds i to the "last_chat_time" field.
func (m *ChatmateMutation) AddLastChatTime(i int64) {
	if m.addlast_chat_time != nil {
		*m.addlast_chat_time += i
	} else {
		m.addlast_chat_time = &i
	}
}

// AddedLastChatTime returns the value that was added to the "last_chat_time" field in this mutation.
func (m *ChatmateMutation) AddedLastChatTime() (r int64, exists bool) {
	v := m.addlast_chat_time
	if v == nil {
		return
	}
	return *v, true
}

// ResetLastChatTime resets all changes to the "last_chat_time" field.
func (m *ChatmateMutation) ResetLastChatTime() {
	m.last_chat_time = nil
	m.addlast_chat_time = nil
}

// Where appends a list predicates to the ChatmateMutation builder.
func (m *ChatmateMutation) Where(ps ...predicate.Chatmate) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ChatmateMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Chatmate).
func (m *ChatmateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ChatmateMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.biz_id != nil {
		fields = append(fields, chatmate.FieldBizID)
	}
	if m._type != nil {
		fields = append(fields, chatmate.FieldType)
	}
	if m.name != nil {
		fields = append(fields, chatmate.FieldName)
	}
	if m.avatar != nil {
		fields = append(fields, chatmate.FieldAvatar)
	}
	if m.last_message_id != nil {
		fields = append(fields, chatmate.FieldLastMessageID)
	}
	if m.last_chat_time != nil {
		fields = append(fields, chatmate.FieldLastChatTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ChatmateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case chatmate.FieldBizID:
		return m.BizID()
	case chatmate.FieldType:
		return m.GetType()
	case chatmate.FieldName:
		return m.Name()
	case chatmate.FieldAvatar:
		return m.Avatar()
	case chatmate.FieldLastMessageID:
		return m.LastMessageID()
	case chatmate.FieldLastChatTime:
		return m.LastChatTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ChatmateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case chatmate.FieldBizID:
		return m.OldBizID(ctx)
	case chatmate.FieldType:
		return m.OldType(ctx)
	case chatmate.FieldName:
		return m.OldName(ctx)
	case chatmate.FieldAvatar:
		return m.OldAvatar(ctx)
	case chatmate.FieldLastMessageID:
		return m.OldLastMessageID(ctx)
	case chatmate.FieldLastChatTime:
		return m.OldLastChatTime(ctx)
	}
	return nil, fmt.Errorf("unknown Chatmate field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChatmateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case chatmate.FieldBizID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBizID(v)
		return nil
	case chatmate.FieldType:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case chatmate.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case chatmate.FieldAvatar:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatar(v)
		return nil
	case chatmate.FieldLastMessageID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastMessageID(v)
		return nil
	case chatmate.FieldLastChatTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastChatTime(v)
		return nil
	}
	return fmt.Errorf("unknown Chatmate field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ChatmateMutation) AddedFields() []string {
	var fields []string
	if m.addbiz_id != nil {
		fields = append(fields, chatmate.FieldBizID)
	}
	if m.add_type != nil {
		fields = append(fields, chatmate.FieldType)
	}
	if m.addlast_message_id != nil {
		fields = append(fields, chatmate.FieldLastMessageID)
	}
	if m.addlast_chat_time != nil {
		fields = append(fields, chatmate.FieldLastChatTime)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ChatmateMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case chatmate.FieldBizID:
		return m.AddedBizID()
	case chatmate.FieldType:
		return m.AddedType()
	case chatmate.FieldLastMessageID:
		return m.AddedLastMessageID()
	case chatmate.FieldLastChatTime:
		return m.AddedLastChatTime()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChatmateMutation) AddField(name string, value ent.Value) error {
	switch name {
	case chatmate.FieldBizID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBizID(v)
		return nil
	case chatmate.FieldType:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	case chatmate.FieldLastMessageID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLastMessageID(v)
		return nil
	case chatmate.FieldLastChatTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLastChatTime(v)
		return nil
	}
	return fmt.Errorf("unknown Chatmate numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ChatmateMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ChatmateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ChatmateMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Chatmate nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ChatmateMutation) ResetField(name string) error {
	switch name {
	case chatmate.FieldBizID:
		m.ResetBizID()
		return nil
	case chatmate.FieldType:
		m.ResetType()
		return nil
	case chatmate.FieldName:
		m.ResetName()
		return nil
	case chatmate.FieldAvatar:
		m.ResetAvatar()
		return nil
	case chatmate.FieldLastMessageID:
		m.ResetLastMessageID()
		return nil
	case chatmate.FieldLastChatTime:
		m.ResetLastChatTime()
		return nil
	}
	return fmt.Errorf("unknown Chatmate field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ChatmateMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ChatmateMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ChatmateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ChatmateMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ChatmateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ChatmateMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ChatmateMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Chatmate unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ChatmateMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Chatmate edge %s", name)
}

// ConfMutation represents an operation that mutates the Conf nodes in the graph.
type ConfMutation struct {
	config
	op            Op
	typ           string
	id            *string
	value         *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Conf, error)
	predicates    []predicate.Conf
}

var _ ent.Mutation = (*ConfMutation)(nil)

// confOption allows management of the mutation configuration using functional options.
type confOption func(*ConfMutation)

// newConfMutation creates new mutation for the Conf entity.
func newConfMutation(c config, op Op, opts ...confOption) *ConfMutation {
	m := &ConfMutation{
		config:        c,
		op:            op,
		typ:           TypeConf,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withConfID sets the ID field of the mutation.
func withConfID(id string) confOption {
	return func(m *ConfMutation) {
		var (
			err   error
			once  sync.Once
			value *Conf
		)
		m.oldValue = func(ctx context.Context) (*Conf, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Conf.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withConf sets the old Conf of the mutation.
func withConf(node *Conf) confOption {
	return func(m *ConfMutation) {
		m.oldValue = func(context.Context) (*Conf, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ConfMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ConfMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Conf entities.
func (m *ConfMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ConfMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ConfMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Conf.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetValue sets the "value" field.
func (m *ConfMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *ConfMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the Conf entity.
// If the Conf object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *ConfMutation) ResetValue() {
	m.value = nil
}

// Where appends a list predicates to the ConfMutation builder.
func (m *ConfMutation) Where(ps ...predicate.Conf) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ConfMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Conf).
func (m *ConfMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ConfMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.value != nil {
		fields = append(fields, conf.FieldValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ConfMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case conf.FieldValue:
		return m.Value()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ConfMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case conf.FieldValue:
		return m.OldValue(ctx)
	}
	return nil, fmt.Errorf("unknown Conf field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConfMutation) SetField(name string, value ent.Value) error {
	switch name {
	case conf.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	}
	return fmt.Errorf("unknown Conf field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ConfMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ConfMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConfMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Conf numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ConfMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ConfMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ConfMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Conf nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ConfMutation) ResetField(name string) error {
	switch name {
	case conf.FieldValue:
		m.ResetValue()
		return nil
	}
	return fmt.Errorf("unknown Conf field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ConfMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ConfMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ConfMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ConfMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ConfMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ConfMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ConfMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Conf unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ConfMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Conf edge %s", name)
}

// ContactMutation represents an operation that mutates the Contact nodes in the graph.
type ContactMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	user_id       *int64
	adduser_id    *int64
	username      *string
	nickname      *string
	avatar        *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Contact, error)
	predicates    []predicate.Contact
}

var _ ent.Mutation = (*ContactMutation)(nil)

// contactOption allows management of the mutation configuration using functional options.
type contactOption func(*ContactMutation)

// newContactMutation creates new mutation for the Contact entity.
func newContactMutation(c config, op Op, opts ...contactOption) *ContactMutation {
	m := &ContactMutation{
		config:        c,
		op:            op,
		typ:           TypeContact,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withContactID sets the ID field of the mutation.
func withContactID(id int64) contactOption {
	return func(m *ContactMutation) {
		var (
			err   error
			once  sync.Once
			value *Contact
		)
		m.oldValue = func(ctx context.Context) (*Contact, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Contact.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withContact sets the old Contact of the mutation.
func withContact(node *Contact) contactOption {
	return func(m *ContactMutation) {
		m.oldValue = func(context.Context) (*Contact, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ContactMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ContactMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Contact entities.
func (m *ContactMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ContactMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ContactMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Contact.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *ContactMutation) SetUserID(i int64) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *ContactMutation) UserID() (r int64, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Contact entity.
// If the Contact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *ContactMutation) AddUserID(i int64) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *ContactMutation) AddedUserID() (r int64, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *ContactMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetUsername sets the "username" field.
func (m *ContactMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *ContactMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the Contact entity.
// If the Contact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *ContactMutation) ResetUsername() {
	m.username = nil
}

// SetNickname sets the "nickname" field.
func (m *ContactMutation) SetNickname(s string) {
	m.nickname = &s
}

// Nickname returns the value of the "nickname" field in the mutation.
func (m *ContactMutation) Nickname() (r string, exists bool) {
	v := m.nickname
	if v == nil {
		return
	}
	return *v, true
}

// OldNickname returns the old "nickname" field's value of the Contact entity.
// If the Contact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactMutation) OldNickname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNickname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNickname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNickname: %w", err)
	}
	return oldValue.Nickname, nil
}

// ResetNickname resets all changes to the "nickname" field.
func (m *ContactMutation) ResetNickname() {
	m.nickname = nil
}

// SetAvatar sets the "avatar" field.
func (m *ContactMutation) SetAvatar(s string) {
	m.avatar = &s
}

// Avatar returns the value of the "avatar" field in the mutation.
func (m *ContactMutation) Avatar() (r string, exists bool) {
	v := m.avatar
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatar returns the old "avatar" field's value of the Contact entity.
// If the Contact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactMutation) OldAvatar(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatar: %w", err)
	}
	return oldValue.Avatar, nil
}

// ResetAvatar resets all changes to the "avatar" field.
func (m *ContactMutation) ResetAvatar() {
	m.avatar = nil
}

// Where appends a list predicates to the ContactMutation builder.
func (m *ContactMutation) Where(ps ...predicate.Contact) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ContactMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Contact).
func (m *ContactMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ContactMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.user_id != nil {
		fields = append(fields, contact.FieldUserID)
	}
	if m.username != nil {
		fields = append(fields, contact.FieldUsername)
	}
	if m.nickname != nil {
		fields = append(fields, contact.FieldNickname)
	}
	if m.avatar != nil {
		fields = append(fields, contact.FieldAvatar)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ContactMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case contact.FieldUserID:
		return m.UserID()
	case contact.FieldUsername:
		return m.Username()
	case contact.FieldNickname:
		return m.Nickname()
	case contact.FieldAvatar:
		return m.Avatar()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ContactMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case contact.FieldUserID:
		return m.OldUserID(ctx)
	case contact.FieldUsername:
		return m.OldUsername(ctx)
	case contact.FieldNickname:
		return m.OldNickname(ctx)
	case contact.FieldAvatar:
		return m.OldAvatar(ctx)
	}
	return nil, fmt.Errorf("unknown Contact field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ContactMutation) SetField(name string, value ent.Value) error {
	switch name {
	case contact.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case contact.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case contact.FieldNickname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNickname(v)
		return nil
	case contact.FieldAvatar:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatar(v)
		return nil
	}
	return fmt.Errorf("unknown Contact field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ContactMutation) AddedFields() []string {
	var fields []string
	if m.adduser_id != nil {
		fields = append(fields, contact.FieldUserID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ContactMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case contact.FieldUserID:
		return m.AddedUserID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ContactMutation) AddField(name string, value ent.Value) error {
	switch name {
	case contact.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	}
	return fmt.Errorf("unknown Contact numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ContactMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ContactMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ContactMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Contact nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ContactMutation) ResetField(name string) error {
	switch name {
	case contact.FieldUserID:
		m.ResetUserID()
		return nil
	case contact.FieldUsername:
		m.ResetUsername()
		return nil
	case contact.FieldNickname:
		m.ResetNickname()
		return nil
	case contact.FieldAvatar:
		m.ResetAvatar()
		return nil
	}
	return fmt.Errorf("unknown Contact field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ContactMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ContactMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ContactMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ContactMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ContactMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ContactMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ContactMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Contact unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ContactMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Contact edge %s", name)
}

// GroupMutation represents an operation that mutates the Group nodes in the graph.
type GroupMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	name          *string
	avatar        *string
	owner         *int64
	addowner      *int64
	size          *int32
	addsize       *int32
	status        *int32
	addstatus     *int32
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Group, error)
	predicates    []predicate.Group
}

var _ ent.Mutation = (*GroupMutation)(nil)

// groupOption allows management of the mutation configuration using functional options.
type groupOption func(*GroupMutation)

// newGroupMutation creates new mutation for the Group entity.
func newGroupMutation(c config, op Op, opts ...groupOption) *GroupMutation {
	m := &GroupMutation{
		config:        c,
		op:            op,
		typ:           TypeGroup,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGroupID sets the ID field of the mutation.
func withGroupID(id int64) groupOption {
	return func(m *GroupMutation) {
		var (
			err   error
			once  sync.Once
			value *Group
		)
		m.oldValue = func(ctx context.Context) (*Group, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Group.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGroup sets the old Group of the mutation.
func withGroup(node *Group) groupOption {
	return func(m *GroupMutation) {
		m.oldValue = func(context.Context) (*Group, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GroupMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GroupMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Group entities.
func (m *GroupMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GroupMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GroupMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Group.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *GroupMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *GroupMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *GroupMutation) ResetName() {
	m.name = nil
}

// SetAvatar sets the "avatar" field.
func (m *GroupMutation) SetAvatar(s string) {
	m.avatar = &s
}

// Avatar returns the value of the "avatar" field in the mutation.
func (m *GroupMutation) Avatar() (r string, exists bool) {
	v := m.avatar
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatar returns the old "avatar" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldAvatar(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatar: %w", err)
	}
	return oldValue.Avatar, nil
}

// ResetAvatar resets all changes to the "avatar" field.
func (m *GroupMutation) ResetAvatar() {
	m.avatar = nil
}

// SetOwner sets the "owner" field.
func (m *GroupMutation) SetOwner(i int64) {
	m.owner = &i
	m.addowner = nil
}

// Owner returns the value of the "owner" field in the mutation.
func (m *GroupMutation) Owner() (r int64, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldOwner returns the old "owner" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldOwner(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwner is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwner requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwner: %w", err)
	}
	return oldValue.Owner, nil
}

// AddOwner adds i to the "owner" field.
func (m *GroupMutation) AddOwner(i int64) {
	if m.addowner != nil {
		*m.addowner += i
	} else {
		m.addowner = &i
	}
}

// AddedOwner returns the value that was added to the "owner" field in this mutation.
func (m *GroupMutation) AddedOwner() (r int64, exists bool) {
	v := m.addowner
	if v == nil {
		return
	}
	return *v, true
}

// ResetOwner resets all changes to the "owner" field.
func (m *GroupMutation) ResetOwner() {
	m.owner = nil
	m.addowner = nil
}

// SetSize sets the "size" field.
func (m *GroupMutation) SetSize(i int32) {
	m.size = &i
	m.addsize = nil
}

// Size returns the value of the "size" field in the mutation.
func (m *GroupMutation) Size() (r int32, exists bool) {
	v := m.size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old "size" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldSize(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// AddSize adds i to the "size" field.
func (m *GroupMutation) AddSize(i int32) {
	if m.addsize != nil {
		*m.addsize += i
	} else {
		m.addsize = &i
	}
}

// AddedSize returns the value that was added to the "size" field in this mutation.
func (m *GroupMutation) AddedSize() (r int32, exists bool) {
	v := m.addsize
	if v == nil {
		return
	}
	return *v, true
}

// ResetSize resets all changes to the "size" field.
func (m *GroupMutation) ResetSize() {
	m.size = nil
	m.addsize = nil
}

// SetStatus sets the "status" field.
func (m *GroupMutation) SetStatus(i int32) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *GroupMutation) Status() (r int32, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldStatus(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *GroupMutation) AddStatus(i int32) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *GroupMutation) AddedStatus() (r int32, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *GroupMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// Where appends a list predicates to the GroupMutation builder.
func (m *GroupMutation) Where(ps ...predicate.Group) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *GroupMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Group).
func (m *GroupMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GroupMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.name != nil {
		fields = append(fields, group.FieldName)
	}
	if m.avatar != nil {
		fields = append(fields, group.FieldAvatar)
	}
	if m.owner != nil {
		fields = append(fields, group.FieldOwner)
	}
	if m.size != nil {
		fields = append(fields, group.FieldSize)
	}
	if m.status != nil {
		fields = append(fields, group.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GroupMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case group.FieldName:
		return m.Name()
	case group.FieldAvatar:
		return m.Avatar()
	case group.FieldOwner:
		return m.Owner()
	case group.FieldSize:
		return m.Size()
	case group.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GroupMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case group.FieldName:
		return m.OldName(ctx)
	case group.FieldAvatar:
		return m.OldAvatar(ctx)
	case group.FieldOwner:
		return m.OldOwner(ctx)
	case group.FieldSize:
		return m.OldSize(ctx)
	case group.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Group field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GroupMutation) SetField(name string, value ent.Value) error {
	switch name {
	case group.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case group.FieldAvatar:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatar(v)
		return nil
	case group.FieldOwner:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwner(v)
		return nil
	case group.FieldSize:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	case group.FieldStatus:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Group field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GroupMutation) AddedFields() []string {
	var fields []string
	if m.addowner != nil {
		fields = append(fields, group.FieldOwner)
	}
	if m.addsize != nil {
		fields = append(fields, group.FieldSize)
	}
	if m.addstatus != nil {
		fields = append(fields, group.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GroupMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case group.FieldOwner:
		return m.AddedOwner()
	case group.FieldSize:
		return m.AddedSize()
	case group.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GroupMutation) AddField(name string, value ent.Value) error {
	switch name {
	case group.FieldOwner:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOwner(v)
		return nil
	case group.FieldSize:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSize(v)
		return nil
	case group.FieldStatus:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Group numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GroupMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GroupMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GroupMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Group nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GroupMutation) ResetField(name string) error {
	switch name {
	case group.FieldName:
		m.ResetName()
		return nil
	case group.FieldAvatar:
		m.ResetAvatar()
		return nil
	case group.FieldOwner:
		m.ResetOwner()
		return nil
	case group.FieldSize:
		m.ResetSize()
		return nil
	case group.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Group field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GroupMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GroupMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GroupMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GroupMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GroupMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GroupMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GroupMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Group unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GroupMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Group edge %s", name)
}

// GroupMessageMutation represents an operation that mutates the GroupMessage nodes in the graph.
type GroupMessageMutation struct {
	config
	op              Op
	typ             string
	id              *int64
	group_id        *int64
	addgroup_id     *int64
	sender          *int64
	addsender       *int64
	recipient       *int64
	addrecipient    *int64
	_type           *int32
	add_type        *int32
	content         *string
	sent_time       *int64
	addsent_time    *int64
	taken_time      *int64
	addtaken_time   *int64
	seen_time       *int64
	addseen_time    *int64
	revoked_time    *int64
	addrevoked_time *int64
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*GroupMessage, error)
	predicates      []predicate.GroupMessage
}

var _ ent.Mutation = (*GroupMessageMutation)(nil)

// groupmessageOption allows management of the mutation configuration using functional options.
type groupmessageOption func(*GroupMessageMutation)

// newGroupMessageMutation creates new mutation for the GroupMessage entity.
func newGroupMessageMutation(c config, op Op, opts ...groupmessageOption) *GroupMessageMutation {
	m := &GroupMessageMutation{
		config:        c,
		op:            op,
		typ:           TypeGroupMessage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGroupMessageID sets the ID field of the mutation.
func withGroupMessageID(id int64) groupmessageOption {
	return func(m *GroupMessageMutation) {
		var (
			err   error
			once  sync.Once
			value *GroupMessage
		)
		m.oldValue = func(ctx context.Context) (*GroupMessage, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GroupMessage.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGroupMessage sets the old GroupMessage of the mutation.
func withGroupMessage(node *GroupMessage) groupmessageOption {
	return func(m *GroupMessageMutation) {
		m.oldValue = func(context.Context) (*GroupMessage, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GroupMessageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GroupMessageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of GroupMessage entities.
func (m *GroupMessageMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GroupMessageMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GroupMessageMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().GroupMessage.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetGroupID sets the "group_id" field.
func (m *GroupMessageMutation) SetGroupID(i int64) {
	m.group_id = &i
	m.addgroup_id = nil
}

// GroupID returns the value of the "group_id" field in the mutation.
func (m *GroupMessageMutation) GroupID() (r int64, exists bool) {
	v := m.group_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGroupID returns the old "group_id" field's value of the GroupMessage entity.
// If the GroupMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMessageMutation) OldGroupID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGroupID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGroupID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroupID: %w", err)
	}
	return oldValue.GroupID, nil
}

// AddGroupID adds i to the "group_id" field.
func (m *GroupMessageMutation) AddGroupID(i int64) {
	if m.addgroup_id != nil {
		*m.addgroup_id += i
	} else {
		m.addgroup_id = &i
	}
}

// AddedGroupID returns the value that was added to the "group_id" field in this mutation.
func (m *GroupMessageMutation) AddedGroupID() (r int64, exists bool) {
	v := m.addgroup_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetGroupID resets all changes to the "group_id" field.
func (m *GroupMessageMutation) ResetGroupID() {
	m.group_id = nil
	m.addgroup_id = nil
}

// SetSender sets the "sender" field.
func (m *GroupMessageMutation) SetSender(i int64) {
	m.sender = &i
	m.addsender = nil
}

// Sender returns the value of the "sender" field in the mutation.
func (m *GroupMessageMutation) Sender() (r int64, exists bool) {
	v := m.sender
	if v == nil {
		return
	}
	return *v, true
}

// OldSender returns the old "sender" field's value of the GroupMessage entity.
// If the GroupMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMessageMutation) OldSender(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSender is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSender requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSender: %w", err)
	}
	return oldValue.Sender, nil
}

// AddSender adds i to the "sender" field.
func (m *GroupMessageMutation) AddSender(i int64) {
	if m.addsender != nil {
		*m.addsender += i
	} else {
		m.addsender = &i
	}
}

// AddedSender returns the value that was added to the "sender" field in this mutation.
func (m *GroupMessageMutation) AddedSender() (r int64, exists bool) {
	v := m.addsender
	if v == nil {
		return
	}
	return *v, true
}

// ResetSender resets all changes to the "sender" field.
func (m *GroupMessageMutation) ResetSender() {
	m.sender = nil
	m.addsender = nil
}

// SetRecipient sets the "recipient" field.
func (m *GroupMessageMutation) SetRecipient(i int64) {
	m.recipient = &i
	m.addrecipient = nil
}

// Recipient returns the value of the "recipient" field in the mutation.
func (m *GroupMessageMutation) Recipient() (r int64, exists bool) {
	v := m.recipient
	if v == nil {
		return
	}
	return *v, true
}

// OldRecipient returns the old "recipient" field's value of the GroupMessage entity.
// If the GroupMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMessageMutation) OldRecipient(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecipient is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecipient requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecipient: %w", err)
	}
	return oldValue.Recipient, nil
}

// AddRecipient adds i to the "recipient" field.
func (m *GroupMessageMutation) AddRecipient(i int64) {
	if m.addrecipient != nil {
		*m.addrecipient += i
	} else {
		m.addrecipient = &i
	}
}

// AddedRecipient returns the value that was added to the "recipient" field in this mutation.
func (m *GroupMessageMutation) AddedRecipient() (r int64, exists bool) {
	v := m.addrecipient
	if v == nil {
		return
	}
	return *v, true
}

// ResetRecipient resets all changes to the "recipient" field.
func (m *GroupMessageMutation) ResetRecipient() {
	m.recipient = nil
	m.addrecipient = nil
}

// SetType sets the "type" field.
func (m *GroupMessageMutation) SetType(i int32) {
	m._type = &i
	m.add_type = nil
}

// GetType returns the value of the "type" field in the mutation.
func (m *GroupMessageMutation) GetType() (r int32, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the GroupMessage entity.
// If the GroupMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMessageMutation) OldType(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds i to the "type" field.
func (m *GroupMessageMutation) AddType(i int32) {
	if m.add_type != nil {
		*m.add_type += i
	} else {
		m.add_type = &i
	}
}

// AddedType returns the value that was added to the "type" field in this mutation.
func (m *GroupMessageMutation) AddedType() (r int32, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetType resets all changes to the "type" field.
func (m *GroupMessageMutation) ResetType() {
	m._type = nil
	m.add_type = nil
}

// SetContent sets the "content" field.
func (m *GroupMessageMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *GroupMessageMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the GroupMessage entity.
// If the GroupMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMessageMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *GroupMessageMutation) ResetContent() {
	m.content = nil
}

// SetSentTime sets the "sent_time" field.
func (m *GroupMessageMutation) SetSentTime(i int64) {
	m.sent_time = &i
	m.addsent_time = nil
}

// SentTime returns the value of the "sent_time" field in the mutation.
func (m *GroupMessageMutation) SentTime() (r int64, exists bool) {
	v := m.sent_time
	if v == nil {
		return
	}
	return *v, true
}

// OldSentTime returns the old "sent_time" field's value of the GroupMessage entity.
// If the GroupMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMessageMutation) OldSentTime(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSentTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSentTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSentTime: %w", err)
	}
	return oldValue.SentTime, nil
}

// AddSentTime adds i to the "sent_time" field.
func (m *GroupMessageMutation) AddSentTime(i int64) {
	if m.addsent_time != nil {
		*m.addsent_time += i
	} else {
		m.addsent_time = &i
	}
}

// AddedSentTime returns the value that was added to the "sent_time" field in this mutation.
func (m *GroupMessageMutation) AddedSentTime() (r int64, exists bool) {
	v := m.addsent_time
	if v == nil {
		return
	}
	return *v, true
}

// ResetSentTime resets all changes to the "sent_time" field.
func (m *GroupMessageMutation) ResetSentTime() {
	m.sent_time = nil
	m.addsent_time = nil
}

// SetTakenTime sets the "taken_time" field.
func (m *GroupMessageMutation) SetTakenTime(i int64) {
	m.taken_time = &i
	m.addtaken_time = nil
}

// TakenTime returns the value of the "taken_time" field in the mutation.
func (m *GroupMessageMutation) TakenTime() (r int64, exists bool) {
	v := m.taken_time
	if v == nil {
		return
	}
	return *v, true
}

// OldTakenTime returns the old "taken_time" field's value of the GroupMessage entity.
// If the GroupMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMessageMutation) OldTakenTime(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTakenTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTakenTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTakenTime: %w", err)
	}
	return oldValue.TakenTime, nil
}

// AddTakenTime adds i to the "taken_time" field.
func (m *GroupMessageMutation) AddTakenTime(i int64) {
	if m.addtaken_time != nil {
		*m.addtaken_time += i
	} else {
		m.addtaken_time = &i
	}
}

// AddedTakenTime returns the value that was added to the "taken_time" field in this mutation.
func (m *GroupMessageMutation) AddedTakenTime() (r int64, exists bool) {
	v := m.addtaken_time
	if v == nil {
		return
	}
	return *v, true
}

// ClearTakenTime clears the value of the "taken_time" field.
func (m *GroupMessageMutation) ClearTakenTime() {
	m.taken_time = nil
	m.addtaken_time = nil
	m.clearedFields[groupmessage.FieldTakenTime] = struct{}{}
}

// TakenTimeCleared returns if the "taken_time" field was cleared in this mutation.
func (m *GroupMessageMutation) TakenTimeCleared() bool {
	_, ok := m.clearedFields[groupmessage.FieldTakenTime]
	return ok
}

// ResetTakenTime resets all changes to the "taken_time" field.
func (m *GroupMessageMutation) ResetTakenTime() {
	m.taken_time = nil
	m.addtaken_time = nil
	delete(m.clearedFields, groupmessage.FieldTakenTime)
}

// SetSeenTime sets the "seen_time" field.
func (m *GroupMessageMutation) SetSeenTime(i int64) {
	m.seen_time = &i
	m.addseen_time = nil
}

// SeenTime returns the value of the "seen_time" field in the mutation.
func (m *GroupMessageMutation) SeenTime() (r int64, exists bool) {
	v := m.seen_time
	if v == nil {
		return
	}
	return *v, true
}

// OldSeenTime returns the old "seen_time" field's value of the GroupMessage entity.
// If the GroupMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMessageMutation) OldSeenTime(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeenTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeenTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeenTime: %w", err)
	}
	return oldValue.SeenTime, nil
}

// AddSeenTime adds i to the "seen_time" field.
func (m *GroupMessageMutation) AddSeenTime(i int64) {
	if m.addseen_time != nil {
		*m.addseen_time += i
	} else {
		m.addseen_time = &i
	}
}

// AddedSeenTime returns the value that was added to the "seen_time" field in this mutation.
func (m *GroupMessageMutation) AddedSeenTime() (r int64, exists bool) {
	v := m.addseen_time
	if v == nil {
		return
	}
	return *v, true
}

// ClearSeenTime clears the value of the "seen_time" field.
func (m *GroupMessageMutation) ClearSeenTime() {
	m.seen_time = nil
	m.addseen_time = nil
	m.clearedFields[groupmessage.FieldSeenTime] = struct{}{}
}

// SeenTimeCleared returns if the "seen_time" field was cleared in this mutation.
func (m *GroupMessageMutation) SeenTimeCleared() bool {
	_, ok := m.clearedFields[groupmessage.FieldSeenTime]
	return ok
}

// ResetSeenTime resets all changes to the "seen_time" field.
func (m *GroupMessageMutation) ResetSeenTime() {
	m.seen_time = nil
	m.addseen_time = nil
	delete(m.clearedFields, groupmessage.FieldSeenTime)
}

// SetRevokedTime sets the "revoked_time" field.
func (m *GroupMessageMutation) SetRevokedTime(i int64) {
	m.revoked_time = &i
	m.addrevoked_time = nil
}

// RevokedTime returns the value of the "revoked_time" field in the mutation.
func (m *GroupMessageMutation) RevokedTime() (r int64, exists bool) {
	v := m.revoked_time
	if v == nil {
		return
	}
	return *v, true
}

// OldRevokedTime returns the old "revoked_time" field's value of the GroupMessage entity.
// If the GroupMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMessageMutation) OldRevokedTime(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRevokedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRevokedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevokedTime: %w", err)
	}
	return oldValue.RevokedTime, nil
}

// AddRevokedTime adds i to the "revoked_time" field.
func (m *GroupMessageMutation) AddRevokedTime(i int64) {
	if m.addrevoked_time != nil {
		*m.addrevoked_time += i
	} else {
		m.addrevoked_time = &i
	}
}

// AddedRevokedTime returns the value that was added to the "revoked_time" field in this mutation.
func (m *GroupMessageMutation) AddedRevokedTime() (r int64, exists bool) {
	v := m.addrevoked_time
	if v == nil {
		return
	}
	return *v, true
}

// ClearRevokedTime clears the value of the "revoked_time" field.
func (m *GroupMessageMutation) ClearRevokedTime() {
	m.revoked_time = nil
	m.addrevoked_time = nil
	m.clearedFields[groupmessage.FieldRevokedTime] = struct{}{}
}

// RevokedTimeCleared returns if the "revoked_time" field was cleared in this mutation.
func (m *GroupMessageMutation) RevokedTimeCleared() bool {
	_, ok := m.clearedFields[groupmessage.FieldRevokedTime]
	return ok
}

// ResetRevokedTime resets all changes to the "revoked_time" field.
func (m *GroupMessageMutation) ResetRevokedTime() {
	m.revoked_time = nil
	m.addrevoked_time = nil
	delete(m.clearedFields, groupmessage.FieldRevokedTime)
}

// Where appends a list predicates to the GroupMessageMutation builder.
func (m *GroupMessageMutation) Where(ps ...predicate.GroupMessage) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *GroupMessageMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (GroupMessage).
func (m *GroupMessageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GroupMessageMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.group_id != nil {
		fields = append(fields, groupmessage.FieldGroupID)
	}
	if m.sender != nil {
		fields = append(fields, groupmessage.FieldSender)
	}
	if m.recipient != nil {
		fields = append(fields, groupmessage.FieldRecipient)
	}
	if m._type != nil {
		fields = append(fields, groupmessage.FieldType)
	}
	if m.content != nil {
		fields = append(fields, groupmessage.FieldContent)
	}
	if m.sent_time != nil {
		fields = append(fields, groupmessage.FieldSentTime)
	}
	if m.taken_time != nil {
		fields = append(fields, groupmessage.FieldTakenTime)
	}
	if m.seen_time != nil {
		fields = append(fields, groupmessage.FieldSeenTime)
	}
	if m.revoked_time != nil {
		fields = append(fields, groupmessage.FieldRevokedTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GroupMessageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case groupmessage.FieldGroupID:
		return m.GroupID()
	case groupmessage.FieldSender:
		return m.Sender()
	case groupmessage.FieldRecipient:
		return m.Recipient()
	case groupmessage.FieldType:
		return m.GetType()
	case groupmessage.FieldContent:
		return m.Content()
	case groupmessage.FieldSentTime:
		return m.SentTime()
	case groupmessage.FieldTakenTime:
		return m.TakenTime()
	case groupmessage.FieldSeenTime:
		return m.SeenTime()
	case groupmessage.FieldRevokedTime:
		return m.RevokedTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GroupMessageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case groupmessage.FieldGroupID:
		return m.OldGroupID(ctx)
	case groupmessage.FieldSender:
		return m.OldSender(ctx)
	case groupmessage.FieldRecipient:
		return m.OldRecipient(ctx)
	case groupmessage.FieldType:
		return m.OldType(ctx)
	case groupmessage.FieldContent:
		return m.OldContent(ctx)
	case groupmessage.FieldSentTime:
		return m.OldSentTime(ctx)
	case groupmessage.FieldTakenTime:
		return m.OldTakenTime(ctx)
	case groupmessage.FieldSeenTime:
		return m.OldSeenTime(ctx)
	case groupmessage.FieldRevokedTime:
		return m.OldRevokedTime(ctx)
	}
	return nil, fmt.Errorf("unknown GroupMessage field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GroupMessageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case groupmessage.FieldGroupID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroupID(v)
		return nil
	case groupmessage.FieldSender:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSender(v)
		return nil
	case groupmessage.FieldRecipient:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecipient(v)
		return nil
	case groupmessage.FieldType:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case groupmessage.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case groupmessage.FieldSentTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSentTime(v)
		return nil
	case groupmessage.FieldTakenTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTakenTime(v)
		return nil
	case groupmessage.FieldSeenTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeenTime(v)
		return nil
	case groupmessage.FieldRevokedTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevokedTime(v)
		return nil
	}
	return fmt.Errorf("unknown GroupMessage field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GroupMessageMutation) AddedFields() []string {
	var fields []string
	if m.addgroup_id != nil {
		fields = append(fields, groupmessage.FieldGroupID)
	}
	if m.addsender != nil {
		fields = append(fields, groupmessage.FieldSender)
	}
	if m.addrecipient != nil {
		fields = append(fields, groupmessage.FieldRecipient)
	}
	if m.add_type != nil {
		fields = append(fields, groupmessage.FieldType)
	}
	if m.addsent_time != nil {
		fields = append(fields, groupmessage.FieldSentTime)
	}
	if m.addtaken_time != nil {
		fields = append(fields, groupmessage.FieldTakenTime)
	}
	if m.addseen_time != nil {
		fields = append(fields, groupmessage.FieldSeenTime)
	}
	if m.addrevoked_time != nil {
		fields = append(fields, groupmessage.FieldRevokedTime)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GroupMessageMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case groupmessage.FieldGroupID:
		return m.AddedGroupID()
	case groupmessage.FieldSender:
		return m.AddedSender()
	case groupmessage.FieldRecipient:
		return m.AddedRecipient()
	case groupmessage.FieldType:
		return m.AddedType()
	case groupmessage.FieldSentTime:
		return m.AddedSentTime()
	case groupmessage.FieldTakenTime:
		return m.AddedTakenTime()
	case groupmessage.FieldSeenTime:
		return m.AddedSeenTime()
	case groupmessage.FieldRevokedTime:
		return m.AddedRevokedTime()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GroupMessageMutation) AddField(name string, value ent.Value) error {
	switch name {
	case groupmessage.FieldGroupID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGroupID(v)
		return nil
	case groupmessage.FieldSender:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSender(v)
		return nil
	case groupmessage.FieldRecipient:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRecipient(v)
		return nil
	case groupmessage.FieldType:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	case groupmessage.FieldSentTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSentTime(v)
		return nil
	case groupmessage.FieldTakenTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTakenTime(v)
		return nil
	case groupmessage.FieldSeenTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSeenTime(v)
		return nil
	case groupmessage.FieldRevokedTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRevokedTime(v)
		return nil
	}
	return fmt.Errorf("unknown GroupMessage numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GroupMessageMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(groupmessage.FieldTakenTime) {
		fields = append(fields, groupmessage.FieldTakenTime)
	}
	if m.FieldCleared(groupmessage.FieldSeenTime) {
		fields = append(fields, groupmessage.FieldSeenTime)
	}
	if m.FieldCleared(groupmessage.FieldRevokedTime) {
		fields = append(fields, groupmessage.FieldRevokedTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GroupMessageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GroupMessageMutation) ClearField(name string) error {
	switch name {
	case groupmessage.FieldTakenTime:
		m.ClearTakenTime()
		return nil
	case groupmessage.FieldSeenTime:
		m.ClearSeenTime()
		return nil
	case groupmessage.FieldRevokedTime:
		m.ClearRevokedTime()
		return nil
	}
	return fmt.Errorf("unknown GroupMessage nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GroupMessageMutation) ResetField(name string) error {
	switch name {
	case groupmessage.FieldGroupID:
		m.ResetGroupID()
		return nil
	case groupmessage.FieldSender:
		m.ResetSender()
		return nil
	case groupmessage.FieldRecipient:
		m.ResetRecipient()
		return nil
	case groupmessage.FieldType:
		m.ResetType()
		return nil
	case groupmessage.FieldContent:
		m.ResetContent()
		return nil
	case groupmessage.FieldSentTime:
		m.ResetSentTime()
		return nil
	case groupmessage.FieldTakenTime:
		m.ResetTakenTime()
		return nil
	case groupmessage.FieldSeenTime:
		m.ResetSeenTime()
		return nil
	case groupmessage.FieldRevokedTime:
		m.ResetRevokedTime()
		return nil
	}
	return fmt.Errorf("unknown GroupMessage field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GroupMessageMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GroupMessageMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GroupMessageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GroupMessageMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GroupMessageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GroupMessageMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GroupMessageMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown GroupMessage unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GroupMessageMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown GroupMessage edge %s", name)
}

// MessageMutation represents an operation that mutates the Message nodes in the graph.
type MessageMutation struct {
	config
	op              Op
	typ             string
	id              *int64
	sender          *int64
	addsender       *int64
	recipient       *int64
	addrecipient    *int64
	_type           *int32
	add_type        *int32
	content         *string
	sent_time       *int64
	addsent_time    *int64
	taken_time      *int64
	addtaken_time   *int64
	seen_time       *int64
	addseen_time    *int64
	revoked_time    *int64
	addrevoked_time *int64
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*Message, error)
	predicates      []predicate.Message
}

var _ ent.Mutation = (*MessageMutation)(nil)

// messageOption allows management of the mutation configuration using functional options.
type messageOption func(*MessageMutation)

// newMessageMutation creates new mutation for the Message entity.
func newMessageMutation(c config, op Op, opts ...messageOption) *MessageMutation {
	m := &MessageMutation{
		config:        c,
		op:            op,
		typ:           TypeMessage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMessageID sets the ID field of the mutation.
func withMessageID(id int64) messageOption {
	return func(m *MessageMutation) {
		var (
			err   error
			once  sync.Once
			value *Message
		)
		m.oldValue = func(ctx context.Context) (*Message, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Message.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMessage sets the old Message of the mutation.
func withMessage(node *Message) messageOption {
	return func(m *MessageMutation) {
		m.oldValue = func(context.Context) (*Message, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MessageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MessageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Message entities.
func (m *MessageMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MessageMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MessageMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Message.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSender sets the "sender" field.
func (m *MessageMutation) SetSender(i int64) {
	m.sender = &i
	m.addsender = nil
}

// Sender returns the value of the "sender" field in the mutation.
func (m *MessageMutation) Sender() (r int64, exists bool) {
	v := m.sender
	if v == nil {
		return
	}
	return *v, true
}

// OldSender returns the old "sender" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldSender(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSender is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSender requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSender: %w", err)
	}
	return oldValue.Sender, nil
}

// AddSender adds i to the "sender" field.
func (m *MessageMutation) AddSender(i int64) {
	if m.addsender != nil {
		*m.addsender += i
	} else {
		m.addsender = &i
	}
}

// AddedSender returns the value that was added to the "sender" field in this mutation.
func (m *MessageMutation) AddedSender() (r int64, exists bool) {
	v := m.addsender
	if v == nil {
		return
	}
	return *v, true
}

// ResetSender resets all changes to the "sender" field.
func (m *MessageMutation) ResetSender() {
	m.sender = nil
	m.addsender = nil
}

// SetRecipient sets the "recipient" field.
func (m *MessageMutation) SetRecipient(i int64) {
	m.recipient = &i
	m.addrecipient = nil
}

// Recipient returns the value of the "recipient" field in the mutation.
func (m *MessageMutation) Recipient() (r int64, exists bool) {
	v := m.recipient
	if v == nil {
		return
	}
	return *v, true
}

// OldRecipient returns the old "recipient" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldRecipient(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecipient is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecipient requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecipient: %w", err)
	}
	return oldValue.Recipient, nil
}

// AddRecipient adds i to the "recipient" field.
func (m *MessageMutation) AddRecipient(i int64) {
	if m.addrecipient != nil {
		*m.addrecipient += i
	} else {
		m.addrecipient = &i
	}
}

// AddedRecipient returns the value that was added to the "recipient" field in this mutation.
func (m *MessageMutation) AddedRecipient() (r int64, exists bool) {
	v := m.addrecipient
	if v == nil {
		return
	}
	return *v, true
}

// ResetRecipient resets all changes to the "recipient" field.
func (m *MessageMutation) ResetRecipient() {
	m.recipient = nil
	m.addrecipient = nil
}

// SetType sets the "type" field.
func (m *MessageMutation) SetType(i int32) {
	m._type = &i
	m.add_type = nil
}

// GetType returns the value of the "type" field in the mutation.
func (m *MessageMutation) GetType() (r int32, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldType(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds i to the "type" field.
func (m *MessageMutation) AddType(i int32) {
	if m.add_type != nil {
		*m.add_type += i
	} else {
		m.add_type = &i
	}
}

// AddedType returns the value that was added to the "type" field in this mutation.
func (m *MessageMutation) AddedType() (r int32, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetType resets all changes to the "type" field.
func (m *MessageMutation) ResetType() {
	m._type = nil
	m.add_type = nil
}

// SetContent sets the "content" field.
func (m *MessageMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *MessageMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *MessageMutation) ResetContent() {
	m.content = nil
}

// SetSentTime sets the "sent_time" field.
func (m *MessageMutation) SetSentTime(i int64) {
	m.sent_time = &i
	m.addsent_time = nil
}

// SentTime returns the value of the "sent_time" field in the mutation.
func (m *MessageMutation) SentTime() (r int64, exists bool) {
	v := m.sent_time
	if v == nil {
		return
	}
	return *v, true
}

// OldSentTime returns the old "sent_time" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldSentTime(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSentTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSentTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSentTime: %w", err)
	}
	return oldValue.SentTime, nil
}

// AddSentTime adds i to the "sent_time" field.
func (m *MessageMutation) AddSentTime(i int64) {
	if m.addsent_time != nil {
		*m.addsent_time += i
	} else {
		m.addsent_time = &i
	}
}

// AddedSentTime returns the value that was added to the "sent_time" field in this mutation.
func (m *MessageMutation) AddedSentTime() (r int64, exists bool) {
	v := m.addsent_time
	if v == nil {
		return
	}
	return *v, true
}

// ResetSentTime resets all changes to the "sent_time" field.
func (m *MessageMutation) ResetSentTime() {
	m.sent_time = nil
	m.addsent_time = nil
}

// SetTakenTime sets the "taken_time" field.
func (m *MessageMutation) SetTakenTime(i int64) {
	m.taken_time = &i
	m.addtaken_time = nil
}

// TakenTime returns the value of the "taken_time" field in the mutation.
func (m *MessageMutation) TakenTime() (r int64, exists bool) {
	v := m.taken_time
	if v == nil {
		return
	}
	return *v, true
}

// OldTakenTime returns the old "taken_time" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldTakenTime(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTakenTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTakenTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTakenTime: %w", err)
	}
	return oldValue.TakenTime, nil
}

// AddTakenTime adds i to the "taken_time" field.
func (m *MessageMutation) AddTakenTime(i int64) {
	if m.addtaken_time != nil {
		*m.addtaken_time += i
	} else {
		m.addtaken_time = &i
	}
}

// AddedTakenTime returns the value that was added to the "taken_time" field in this mutation.
func (m *MessageMutation) AddedTakenTime() (r int64, exists bool) {
	v := m.addtaken_time
	if v == nil {
		return
	}
	return *v, true
}

// ClearTakenTime clears the value of the "taken_time" field.
func (m *MessageMutation) ClearTakenTime() {
	m.taken_time = nil
	m.addtaken_time = nil
	m.clearedFields[message.FieldTakenTime] = struct{}{}
}

// TakenTimeCleared returns if the "taken_time" field was cleared in this mutation.
func (m *MessageMutation) TakenTimeCleared() bool {
	_, ok := m.clearedFields[message.FieldTakenTime]
	return ok
}

// ResetTakenTime resets all changes to the "taken_time" field.
func (m *MessageMutation) ResetTakenTime() {
	m.taken_time = nil
	m.addtaken_time = nil
	delete(m.clearedFields, message.FieldTakenTime)
}

// SetSeenTime sets the "seen_time" field.
func (m *MessageMutation) SetSeenTime(i int64) {
	m.seen_time = &i
	m.addseen_time = nil
}

// SeenTime returns the value of the "seen_time" field in the mutation.
func (m *MessageMutation) SeenTime() (r int64, exists bool) {
	v := m.seen_time
	if v == nil {
		return
	}
	return *v, true
}

// OldSeenTime returns the old "seen_time" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldSeenTime(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeenTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeenTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeenTime: %w", err)
	}
	return oldValue.SeenTime, nil
}

// AddSeenTime adds i to the "seen_time" field.
func (m *MessageMutation) AddSeenTime(i int64) {
	if m.addseen_time != nil {
		*m.addseen_time += i
	} else {
		m.addseen_time = &i
	}
}

// AddedSeenTime returns the value that was added to the "seen_time" field in this mutation.
func (m *MessageMutation) AddedSeenTime() (r int64, exists bool) {
	v := m.addseen_time
	if v == nil {
		return
	}
	return *v, true
}

// ClearSeenTime clears the value of the "seen_time" field.
func (m *MessageMutation) ClearSeenTime() {
	m.seen_time = nil
	m.addseen_time = nil
	m.clearedFields[message.FieldSeenTime] = struct{}{}
}

// SeenTimeCleared returns if the "seen_time" field was cleared in this mutation.
func (m *MessageMutation) SeenTimeCleared() bool {
	_, ok := m.clearedFields[message.FieldSeenTime]
	return ok
}

// ResetSeenTime resets all changes to the "seen_time" field.
func (m *MessageMutation) ResetSeenTime() {
	m.seen_time = nil
	m.addseen_time = nil
	delete(m.clearedFields, message.FieldSeenTime)
}

// SetRevokedTime sets the "revoked_time" field.
func (m *MessageMutation) SetRevokedTime(i int64) {
	m.revoked_time = &i
	m.addrevoked_time = nil
}

// RevokedTime returns the value of the "revoked_time" field in the mutation.
func (m *MessageMutation) RevokedTime() (r int64, exists bool) {
	v := m.revoked_time
	if v == nil {
		return
	}
	return *v, true
}

// OldRevokedTime returns the old "revoked_time" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldRevokedTime(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRevokedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRevokedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevokedTime: %w", err)
	}
	return oldValue.RevokedTime, nil
}

// AddRevokedTime adds i to the "revoked_time" field.
func (m *MessageMutation) AddRevokedTime(i int64) {
	if m.addrevoked_time != nil {
		*m.addrevoked_time += i
	} else {
		m.addrevoked_time = &i
	}
}

// AddedRevokedTime returns the value that was added to the "revoked_time" field in this mutation.
func (m *MessageMutation) AddedRevokedTime() (r int64, exists bool) {
	v := m.addrevoked_time
	if v == nil {
		return
	}
	return *v, true
}

// ClearRevokedTime clears the value of the "revoked_time" field.
func (m *MessageMutation) ClearRevokedTime() {
	m.revoked_time = nil
	m.addrevoked_time = nil
	m.clearedFields[message.FieldRevokedTime] = struct{}{}
}

// RevokedTimeCleared returns if the "revoked_time" field was cleared in this mutation.
func (m *MessageMutation) RevokedTimeCleared() bool {
	_, ok := m.clearedFields[message.FieldRevokedTime]
	return ok
}

// ResetRevokedTime resets all changes to the "revoked_time" field.
func (m *MessageMutation) ResetRevokedTime() {
	m.revoked_time = nil
	m.addrevoked_time = nil
	delete(m.clearedFields, message.FieldRevokedTime)
}

// Where appends a list predicates to the MessageMutation builder.
func (m *MessageMutation) Where(ps ...predicate.Message) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *MessageMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Message).
func (m *MessageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MessageMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.sender != nil {
		fields = append(fields, message.FieldSender)
	}
	if m.recipient != nil {
		fields = append(fields, message.FieldRecipient)
	}
	if m._type != nil {
		fields = append(fields, message.FieldType)
	}
	if m.content != nil {
		fields = append(fields, message.FieldContent)
	}
	if m.sent_time != nil {
		fields = append(fields, message.FieldSentTime)
	}
	if m.taken_time != nil {
		fields = append(fields, message.FieldTakenTime)
	}
	if m.seen_time != nil {
		fields = append(fields, message.FieldSeenTime)
	}
	if m.revoked_time != nil {
		fields = append(fields, message.FieldRevokedTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MessageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case message.FieldSender:
		return m.Sender()
	case message.FieldRecipient:
		return m.Recipient()
	case message.FieldType:
		return m.GetType()
	case message.FieldContent:
		return m.Content()
	case message.FieldSentTime:
		return m.SentTime()
	case message.FieldTakenTime:
		return m.TakenTime()
	case message.FieldSeenTime:
		return m.SeenTime()
	case message.FieldRevokedTime:
		return m.RevokedTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MessageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case message.FieldSender:
		return m.OldSender(ctx)
	case message.FieldRecipient:
		return m.OldRecipient(ctx)
	case message.FieldType:
		return m.OldType(ctx)
	case message.FieldContent:
		return m.OldContent(ctx)
	case message.FieldSentTime:
		return m.OldSentTime(ctx)
	case message.FieldTakenTime:
		return m.OldTakenTime(ctx)
	case message.FieldSeenTime:
		return m.OldSeenTime(ctx)
	case message.FieldRevokedTime:
		return m.OldRevokedTime(ctx)
	}
	return nil, fmt.Errorf("unknown Message field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MessageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case message.FieldSender:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSender(v)
		return nil
	case message.FieldRecipient:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecipient(v)
		return nil
	case message.FieldType:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case message.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case message.FieldSentTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSentTime(v)
		return nil
	case message.FieldTakenTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTakenTime(v)
		return nil
	case message.FieldSeenTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeenTime(v)
		return nil
	case message.FieldRevokedTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevokedTime(v)
		return nil
	}
	return fmt.Errorf("unknown Message field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MessageMutation) AddedFields() []string {
	var fields []string
	if m.addsender != nil {
		fields = append(fields, message.FieldSender)
	}
	if m.addrecipient != nil {
		fields = append(fields, message.FieldRecipient)
	}
	if m.add_type != nil {
		fields = append(fields, message.FieldType)
	}
	if m.addsent_time != nil {
		fields = append(fields, message.FieldSentTime)
	}
	if m.addtaken_time != nil {
		fields = append(fields, message.FieldTakenTime)
	}
	if m.addseen_time != nil {
		fields = append(fields, message.FieldSeenTime)
	}
	if m.addrevoked_time != nil {
		fields = append(fields, message.FieldRevokedTime)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MessageMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case message.FieldSender:
		return m.AddedSender()
	case message.FieldRecipient:
		return m.AddedRecipient()
	case message.FieldType:
		return m.AddedType()
	case message.FieldSentTime:
		return m.AddedSentTime()
	case message.FieldTakenTime:
		return m.AddedTakenTime()
	case message.FieldSeenTime:
		return m.AddedSeenTime()
	case message.FieldRevokedTime:
		return m.AddedRevokedTime()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MessageMutation) AddField(name string, value ent.Value) error {
	switch name {
	case message.FieldSender:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSender(v)
		return nil
	case message.FieldRecipient:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRecipient(v)
		return nil
	case message.FieldType:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	case message.FieldSentTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSentTime(v)
		return nil
	case message.FieldTakenTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTakenTime(v)
		return nil
	case message.FieldSeenTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSeenTime(v)
		return nil
	case message.FieldRevokedTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRevokedTime(v)
		return nil
	}
	return fmt.Errorf("unknown Message numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MessageMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(message.FieldTakenTime) {
		fields = append(fields, message.FieldTakenTime)
	}
	if m.FieldCleared(message.FieldSeenTime) {
		fields = append(fields, message.FieldSeenTime)
	}
	if m.FieldCleared(message.FieldRevokedTime) {
		fields = append(fields, message.FieldRevokedTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MessageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MessageMutation) ClearField(name string) error {
	switch name {
	case message.FieldTakenTime:
		m.ClearTakenTime()
		return nil
	case message.FieldSeenTime:
		m.ClearSeenTime()
		return nil
	case message.FieldRevokedTime:
		m.ClearRevokedTime()
		return nil
	}
	return fmt.Errorf("unknown Message nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MessageMutation) ResetField(name string) error {
	switch name {
	case message.FieldSender:
		m.ResetSender()
		return nil
	case message.FieldRecipient:
		m.ResetRecipient()
		return nil
	case message.FieldType:
		m.ResetType()
		return nil
	case message.FieldContent:
		m.ResetContent()
		return nil
	case message.FieldSentTime:
		m.ResetSentTime()
		return nil
	case message.FieldTakenTime:
		m.ResetTakenTime()
		return nil
	case message.FieldSeenTime:
		m.ResetSeenTime()
		return nil
	case message.FieldRevokedTime:
		m.ResetRevokedTime()
		return nil
	}
	return fmt.Errorf("unknown Message field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MessageMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MessageMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MessageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MessageMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MessageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MessageMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MessageMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Message unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MessageMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Message edge %s", name)
}

// SessionMutation represents an operation that mutates the Session nodes in the graph.
type SessionMutation struct {
	config
	op              Op
	typ             string
	id              *int64
	user_id         *int64
	adduser_id      *int64
	username        *string
	nickname        *string
	avatar          *string
	access_token    *string
	token_type      *string
	expires_in      *int64
	addexpires_in   *int64
	login_time      *int64
	addlogin_time   *int64
	expired_time    *int64
	addexpired_time *int64
	refresh_time    *int64
	addrefresh_time *int64
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*Session, error)
	predicates      []predicate.Session
}

var _ ent.Mutation = (*SessionMutation)(nil)

// sessionOption allows management of the mutation configuration using functional options.
type sessionOption func(*SessionMutation)

// newSessionMutation creates new mutation for the Session entity.
func newSessionMutation(c config, op Op, opts ...sessionOption) *SessionMutation {
	m := &SessionMutation{
		config:        c,
		op:            op,
		typ:           TypeSession,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSessionID sets the ID field of the mutation.
func withSessionID(id int64) sessionOption {
	return func(m *SessionMutation) {
		var (
			err   error
			once  sync.Once
			value *Session
		)
		m.oldValue = func(ctx context.Context) (*Session, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Session.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSession sets the old Session of the mutation.
func withSession(node *Session) sessionOption {
	return func(m *SessionMutation) {
		m.oldValue = func(context.Context) (*Session, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SessionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SessionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Session entities.
func (m *SessionMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SessionMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SessionMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Session.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *SessionMutation) SetUserID(i int64) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *SessionMutation) UserID() (r int64, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *SessionMutation) AddUserID(i int64) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *SessionMutation) AddedUserID() (r int64, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *SessionMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetUsername sets the "username" field.
func (m *SessionMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *SessionMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *SessionMutation) ResetUsername() {
	m.username = nil
}

// SetNickname sets the "nickname" field.
func (m *SessionMutation) SetNickname(s string) {
	m.nickname = &s
}

// Nickname returns the value of the "nickname" field in the mutation.
func (m *SessionMutation) Nickname() (r string, exists bool) {
	v := m.nickname
	if v == nil {
		return
	}
	return *v, true
}

// OldNickname returns the old "nickname" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldNickname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNickname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNickname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNickname: %w", err)
	}
	return oldValue.Nickname, nil
}

// ResetNickname resets all changes to the "nickname" field.
func (m *SessionMutation) ResetNickname() {
	m.nickname = nil
}

// SetAvatar sets the "avatar" field.
func (m *SessionMutation) SetAvatar(s string) {
	m.avatar = &s
}

// Avatar returns the value of the "avatar" field in the mutation.
func (m *SessionMutation) Avatar() (r string, exists bool) {
	v := m.avatar
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatar returns the old "avatar" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldAvatar(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatar: %w", err)
	}
	return oldValue.Avatar, nil
}

// ResetAvatar resets all changes to the "avatar" field.
func (m *SessionMutation) ResetAvatar() {
	m.avatar = nil
}

// SetAccessToken sets the "access_token" field.
func (m *SessionMutation) SetAccessToken(s string) {
	m.access_token = &s
}

// AccessToken returns the value of the "access_token" field in the mutation.
func (m *SessionMutation) AccessToken() (r string, exists bool) {
	v := m.access_token
	if v == nil {
		return
	}
	return *v, true
}

// OldAccessToken returns the old "access_token" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldAccessToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccessToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccessToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccessToken: %w", err)
	}
	return oldValue.AccessToken, nil
}

// ResetAccessToken resets all changes to the "access_token" field.
func (m *SessionMutation) ResetAccessToken() {
	m.access_token = nil
}

// SetTokenType sets the "token_type" field.
func (m *SessionMutation) SetTokenType(s string) {
	m.token_type = &s
}

// TokenType returns the value of the "token_type" field in the mutation.
func (m *SessionMutation) TokenType() (r string, exists bool) {
	v := m.token_type
	if v == nil {
		return
	}
	return *v, true
}

// OldTokenType returns the old "token_type" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldTokenType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokenType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokenType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokenType: %w", err)
	}
	return oldValue.TokenType, nil
}

// ResetTokenType resets all changes to the "token_type" field.
func (m *SessionMutation) ResetTokenType() {
	m.token_type = nil
}

// SetExpiresIn sets the "expires_in" field.
func (m *SessionMutation) SetExpiresIn(i int64) {
	m.expires_in = &i
	m.addexpires_in = nil
}

// ExpiresIn returns the value of the "expires_in" field in the mutation.
func (m *SessionMutation) ExpiresIn() (r int64, exists bool) {
	v := m.expires_in
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresIn returns the old "expires_in" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldExpiresIn(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresIn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresIn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresIn: %w", err)
	}
	return oldValue.ExpiresIn, nil
}

// AddExpiresIn adds i to the "expires_in" field.
func (m *SessionMutation) AddExpiresIn(i int64) {
	if m.addexpires_in != nil {
		*m.addexpires_in += i
	} else {
		m.addexpires_in = &i
	}
}

// AddedExpiresIn returns the value that was added to the "expires_in" field in this mutation.
func (m *SessionMutation) AddedExpiresIn() (r int64, exists bool) {
	v := m.addexpires_in
	if v == nil {
		return
	}
	return *v, true
}

// ResetExpiresIn resets all changes to the "expires_in" field.
func (m *SessionMutation) ResetExpiresIn() {
	m.expires_in = nil
	m.addexpires_in = nil
}

// SetLoginTime sets the "login_time" field.
func (m *SessionMutation) SetLoginTime(i int64) {
	m.login_time = &i
	m.addlogin_time = nil
}

// LoginTime returns the value of the "login_time" field in the mutation.
func (m *SessionMutation) LoginTime() (r int64, exists bool) {
	v := m.login_time
	if v == nil {
		return
	}
	return *v, true
}

// OldLoginTime returns the old "login_time" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldLoginTime(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLoginTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLoginTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLoginTime: %w", err)
	}
	return oldValue.LoginTime, nil
}

// AddLoginTime adds i to the "login_time" field.
func (m *SessionMutation) AddLoginTime(i int64) {
	if m.addlogin_time != nil {
		*m.addlogin_time += i
	} else {
		m.addlogin_time = &i
	}
}

// AddedLoginTime returns the value that was added to the "login_time" field in this mutation.
func (m *SessionMutation) AddedLoginTime() (r int64, exists bool) {
	v := m.addlogin_time
	if v == nil {
		return
	}
	return *v, true
}

// ResetLoginTime resets all changes to the "login_time" field.
func (m *SessionMutation) ResetLoginTime() {
	m.login_time = nil
	m.addlogin_time = nil
}

// SetExpiredTime sets the "expired_time" field.
func (m *SessionMutation) SetExpiredTime(i int64) {
	m.expired_time = &i
	m.addexpired_time = nil
}

// ExpiredTime returns the value of the "expired_time" field in the mutation.
func (m *SessionMutation) ExpiredTime() (r int64, exists bool) {
	v := m.expired_time
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiredTime returns the old "expired_time" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldExpiredTime(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiredTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiredTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiredTime: %w", err)
	}
	return oldValue.ExpiredTime, nil
}

// AddExpiredTime adds i to the "expired_time" field.
func (m *SessionMutation) AddExpiredTime(i int64) {
	if m.addexpired_time != nil {
		*m.addexpired_time += i
	} else {
		m.addexpired_time = &i
	}
}

// AddedExpiredTime returns the value that was added to the "expired_time" field in this mutation.
func (m *SessionMutation) AddedExpiredTime() (r int64, exists bool) {
	v := m.addexpired_time
	if v == nil {
		return
	}
	return *v, true
}

// ResetExpiredTime resets all changes to the "expired_time" field.
func (m *SessionMutation) ResetExpiredTime() {
	m.expired_time = nil
	m.addexpired_time = nil
}

// SetRefreshTime sets the "refresh_time" field.
func (m *SessionMutation) SetRefreshTime(i int64) {
	m.refresh_time = &i
	m.addrefresh_time = nil
}

// RefreshTime returns the value of the "refresh_time" field in the mutation.
func (m *SessionMutation) RefreshTime() (r int64, exists bool) {
	v := m.refresh_time
	if v == nil {
		return
	}
	return *v, true
}

// OldRefreshTime returns the old "refresh_time" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldRefreshTime(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRefreshTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRefreshTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefreshTime: %w", err)
	}
	return oldValue.RefreshTime, nil
}

// AddRefreshTime adds i to the "refresh_time" field.
func (m *SessionMutation) AddRefreshTime(i int64) {
	if m.addrefresh_time != nil {
		*m.addrefresh_time += i
	} else {
		m.addrefresh_time = &i
	}
}

// AddedRefreshTime returns the value that was added to the "refresh_time" field in this mutation.
func (m *SessionMutation) AddedRefreshTime() (r int64, exists bool) {
	v := m.addrefresh_time
	if v == nil {
		return
	}
	return *v, true
}

// ResetRefreshTime resets all changes to the "refresh_time" field.
func (m *SessionMutation) ResetRefreshTime() {
	m.refresh_time = nil
	m.addrefresh_time = nil
}

// Where appends a list predicates to the SessionMutation builder.
func (m *SessionMutation) Where(ps ...predicate.Session) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *SessionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Session).
func (m *SessionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SessionMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.user_id != nil {
		fields = append(fields, session.FieldUserID)
	}
	if m.username != nil {
		fields = append(fields, session.FieldUsername)
	}
	if m.nickname != nil {
		fields = append(fields, session.FieldNickname)
	}
	if m.avatar != nil {
		fields = append(fields, session.FieldAvatar)
	}
	if m.access_token != nil {
		fields = append(fields, session.FieldAccessToken)
	}
	if m.token_type != nil {
		fields = append(fields, session.FieldTokenType)
	}
	if m.expires_in != nil {
		fields = append(fields, session.FieldExpiresIn)
	}
	if m.login_time != nil {
		fields = append(fields, session.FieldLoginTime)
	}
	if m.expired_time != nil {
		fields = append(fields, session.FieldExpiredTime)
	}
	if m.refresh_time != nil {
		fields = append(fields, session.FieldRefreshTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SessionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case session.FieldUserID:
		return m.UserID()
	case session.FieldUsername:
		return m.Username()
	case session.FieldNickname:
		return m.Nickname()
	case session.FieldAvatar:
		return m.Avatar()
	case session.FieldAccessToken:
		return m.AccessToken()
	case session.FieldTokenType:
		return m.TokenType()
	case session.FieldExpiresIn:
		return m.ExpiresIn()
	case session.FieldLoginTime:
		return m.LoginTime()
	case session.FieldExpiredTime:
		return m.ExpiredTime()
	case session.FieldRefreshTime:
		return m.RefreshTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SessionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case session.FieldUserID:
		return m.OldUserID(ctx)
	case session.FieldUsername:
		return m.OldUsername(ctx)
	case session.FieldNickname:
		return m.OldNickname(ctx)
	case session.FieldAvatar:
		return m.OldAvatar(ctx)
	case session.FieldAccessToken:
		return m.OldAccessToken(ctx)
	case session.FieldTokenType:
		return m.OldTokenType(ctx)
	case session.FieldExpiresIn:
		return m.OldExpiresIn(ctx)
	case session.FieldLoginTime:
		return m.OldLoginTime(ctx)
	case session.FieldExpiredTime:
		return m.OldExpiredTime(ctx)
	case session.FieldRefreshTime:
		return m.OldRefreshTime(ctx)
	}
	return nil, fmt.Errorf("unknown Session field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SessionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case session.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case session.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case session.FieldNickname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNickname(v)
		return nil
	case session.FieldAvatar:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatar(v)
		return nil
	case session.FieldAccessToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccessToken(v)
		return nil
	case session.FieldTokenType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokenType(v)
		return nil
	case session.FieldExpiresIn:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresIn(v)
		return nil
	case session.FieldLoginTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLoginTime(v)
		return nil
	case session.FieldExpiredTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiredTime(v)
		return nil
	case session.FieldRefreshTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefreshTime(v)
		return nil
	}
	return fmt.Errorf("unknown Session field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SessionMutation) AddedFields() []string {
	var fields []string
	if m.adduser_id != nil {
		fields = append(fields, session.FieldUserID)
	}
	if m.addexpires_in != nil {
		fields = append(fields, session.FieldExpiresIn)
	}
	if m.addlogin_time != nil {
		fields = append(fields, session.FieldLoginTime)
	}
	if m.addexpired_time != nil {
		fields = append(fields, session.FieldExpiredTime)
	}
	if m.addrefresh_time != nil {
		fields = append(fields, session.FieldRefreshTime)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SessionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case session.FieldUserID:
		return m.AddedUserID()
	case session.FieldExpiresIn:
		return m.AddedExpiresIn()
	case session.FieldLoginTime:
		return m.AddedLoginTime()
	case session.FieldExpiredTime:
		return m.AddedExpiredTime()
	case session.FieldRefreshTime:
		return m.AddedRefreshTime()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SessionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case session.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case session.FieldExpiresIn:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExpiresIn(v)
		return nil
	case session.FieldLoginTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLoginTime(v)
		return nil
	case session.FieldExpiredTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExpiredTime(v)
		return nil
	case session.FieldRefreshTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRefreshTime(v)
		return nil
	}
	return fmt.Errorf("unknown Session numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SessionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SessionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SessionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Session nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SessionMutation) ResetField(name string) error {
	switch name {
	case session.FieldUserID:
		m.ResetUserID()
		return nil
	case session.FieldUsername:
		m.ResetUsername()
		return nil
	case session.FieldNickname:
		m.ResetNickname()
		return nil
	case session.FieldAvatar:
		m.ResetAvatar()
		return nil
	case session.FieldAccessToken:
		m.ResetAccessToken()
		return nil
	case session.FieldTokenType:
		m.ResetTokenType()
		return nil
	case session.FieldExpiresIn:
		m.ResetExpiresIn()
		return nil
	case session.FieldLoginTime:
		m.ResetLoginTime()
		return nil
	case session.FieldExpiredTime:
		m.ResetExpiredTime()
		return nil
	case session.FieldRefreshTime:
		m.ResetRefreshTime()
		return nil
	}
	return fmt.Errorf("unknown Session field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SessionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SessionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SessionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SessionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SessionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SessionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SessionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Session unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SessionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Session edge %s", name)
}
